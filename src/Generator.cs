namespace GitBuildInfo.SourceGenerator
{
    using System;
    using System.Collections.Generic;
    using System.Text.Json;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;

    internal class Generator
    {
        private GeneratorOptions? options;
        private GitInfo? gitInfo;

        public static string CreateAndGenerateCode(string optionsText, string gitInfoText)
        {
            var generator = Create(optionsText, gitInfoText);
            var splitted = generator.options!.AssemblyType!.Contains(".") ? generator.options!.AssemblyType.Split('.') : Array.Empty<string>();
            var splitted2 = splitted.AsSpan().Slice(0, splitted.Length - 1);
            return generator.GenerateCode(
                splitted2.ToArray(),
                "Elskom.Generic.Libs",
                splitted.Length > 0 ? splitted[splitted2.Length] : generator.options!.AssemblyType).ToFullString();
        }

        public CompilationUnitSyntax GenerateCode(string[] usings, string originalnamespace, string typeName)
            => SyntaxFactory.CompilationUnit().WithUsings(
                    SyntaxFactory.List(
                        string.Equals(string.Join(".", usings), originalnamespace, StringComparison.Ordinal)
                            ? new[]
                            {
                                AddUsing(new[] {"Elskom", "Generic", "Libs"}, true)
                            }
                            : new[]
                            {
                                AddUsing(new[] {"Elskom", "Generic", "Libs"}, true),
                                AddUsing(usings, false)
                            }))
                .WithAttributeLists(
                    SyntaxFactory.SingletonList(
                        SyntaxFactory.AttributeList(
                                SyntaxFactory.SingletonSeparatedList(
                                    SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("GitInformationAttribute"))
                                        .WithArgumentList(
                                            SyntaxFactory.AttributeArgumentList(
                                                SyntaxFactory.SeparatedList<AttributeArgumentSyntax>(
                                                    this.MakeAttributeArgumentList(new[] {this.gitInfo!.GitHead!, this.gitInfo.CommitHash!, this.gitInfo.GitBranch!}, typeName))))))
                            .WithOpenBracketToken(
                                SyntaxFactory.Token(
                                    SyntaxFactory.TriviaList(SyntaxFactory.LineFeed),
                                    SyntaxKind.OpenBracketToken,
                                    SyntaxFactory.TriviaList()))
                            .WithTarget(
                                SyntaxFactory.AttributeTargetSpecifier(SyntaxFactory.Token(SyntaxKind.AssemblyKeyword))
                                    .WithColonToken(
                                        SyntaxFactory.Token(
                                            SyntaxFactory.TriviaList(),
                                            SyntaxKind.ColonToken,
                                            SyntaxFactory.TriviaList(SyntaxFactory.Space))))
                            .WithCloseBracketToken(
                                SyntaxFactory.Token(
                                    SyntaxFactory.TriviaList(),
                                    SyntaxKind.CloseBracketToken,
                                    SyntaxFactory.TriviaList(SyntaxFactory.LineFeed)))));

        private static Generator Create(string optionsText, string gitInfoText)
        {
            var serializerOptions = new JsonSerializerOptions
            {
                AllowTrailingCommas = true,
                ReadCommentHandling = JsonCommentHandling.Skip,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            };
            var generator = new Generator
            {
                options = JsonSerializer.Deserialize<GeneratorOptions>(optionsText, serializerOptions),
                gitInfo = JsonSerializer.Deserialize<GitInfo>(gitInfoText, serializerOptions),
            };
            if (string.IsNullOrEmpty(generator.options!.AssemblyType))
            {
                throw new InvalidOperationException("AssemblyType should not be null or an empty string.");
            }

            return generator;
        }

        private static UsingDirectiveSyntax AddUsing(string[] strings, bool autogeneratedheader)
        {
            NameSyntax? qualifiedName = null;
            List<string> strs = new();
            foreach (var str in strings)
            {
                // avoid regressions here.
                if (strs.Contains(str))
                {
                    continue;
                }

                qualifiedName = strings.Length > 1 && str == strings[0]
                    ? SyntaxFactory.QualifiedName(
                        SyntaxFactory.IdentifierName(str),
                        SyntaxFactory.IdentifierName(strings[Array.IndexOf(strings, str) + 1]))
                    : strings.Length is 1
                        ? SyntaxFactory.IdentifierName(str)
                        : SyntaxFactory.QualifiedName(qualifiedName!, SyntaxFactory.IdentifierName(str));
                strs.Add(str);
                if (strings.Length > 1 && str == strings[0])
                {
                    strs.Add(strings[Array.IndexOf(strings, str) + 1]);
                }
            }

            strs.Clear();
            return SyntaxFactory.UsingDirective(qualifiedName!)
                .WithUsingKeyword(SyntaxFactory.Token(
                    SyntaxFactory.TriviaList(autogeneratedheader
                        ? new[] {SyntaxFactory.Comment("// <autogenerated/>"), SyntaxFactory.LineFeed}
                        : Array.Empty<SyntaxTrivia>()),
                    SyntaxKind.UsingKeyword,
                    SyntaxFactory.TriviaList(SyntaxFactory.Space)))
                .WithSemicolonToken(SyntaxFactory.Token(
                    SyntaxFactory.TriviaList(),
                    SyntaxKind.SemicolonToken,
                    SyntaxFactory.TriviaList(SyntaxFactory.LineFeed)));
        }

        private SyntaxNodeOrToken[] MakeAttributeArgumentList(string[] args, string typeName)
        {
            var lst = new SyntaxNodeOrToken[7];
            var lstIndex = 0;
            foreach (var arg in args)
            {
                lst[lstIndex] = SyntaxFactory.AttributeArgument(
                    SyntaxFactory.LiteralExpression(
                        SyntaxKind.StringLiteralExpression,
                        SyntaxFactory.Literal(arg)));
                lstIndex++;
                lst[lstIndex] = SyntaxFactory.Token(
                    SyntaxFactory.TriviaList(),
                    SyntaxKind.CommaToken,
                    SyntaxFactory.TriviaList(SyntaxFactory.Space));
                lstIndex++;
            }

            lst[lstIndex] = SyntaxFactory.AttributeArgument(
                SyntaxFactory.TypeOfExpression(
                    this.options!.IsGeneric
                        ? SyntaxFactory.GenericName(typeName)
                        : SyntaxFactory.IdentifierName(typeName)));
            return lst;
        }
    }
}
