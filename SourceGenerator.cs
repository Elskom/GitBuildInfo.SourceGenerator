namespace GitBuildInfo.SourceGenerator
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Text.Json;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;

    /// <summary>
    /// Source Generator for dumping git build information into a assembly level attribute on the compilation.
    /// </summary>
    [Generator]
    public class SourceGenerator : ISourceGenerator
    {
        /// <inheritdoc/>
        public void Initialize(GeneratorInitializationContext context)
        {
        }

        /// <inheritdoc/>
        public void Execute(GeneratorExecutionContext context)
        {
            if (context.Compilation is not CSharpCompilation)
            {
                return;
            }

            GeneratorOptions? options = null;
            var gitBuildInfoJsonFile = context.AdditionalFiles
                .FirstOrDefault(af => string.Equals(Path.GetFileName(af.Path), "GitBuildInfo.json", StringComparison.OrdinalIgnoreCase));
            if (gitBuildInfoJsonFile is object)
            {
                var optionsJson = gitBuildInfoJsonFile.GetText(context.CancellationToken)!.ToString();
                options = JsonSerializer.Deserialize<GeneratorOptions>(optionsJson, new JsonSerializerOptions
                {
                    AllowTrailingCommas = true,
                    ReadCommentHandling = JsonCommentHandling.Skip,
                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                });
            }

            if (options is null || gitBuildInfoJsonFile is null)
            {
                return;
            }

            if (string.IsNullOrEmpty(options.AssemblyType))
            {
                throw new GenerationFailedException("AssemblyType should not be null or an empty string.");
            }

            var splitted = options.AssemblyType!.Contains(".") ? options.AssemblyType.Split('.') : new string[] { };
            var splittedLen = splitted.Length;
            var usingStr = new StringBuilder();
            var gitinformationNamespace = "Elskom.Generic.Libs";
            foreach (var value in splitted)
            {
                // skip the last value.
                if (value != splitted[splittedLen - 1])
                {
                    _ = usingStr.Append(value != splitted[0] ? "." : value);
                }
            }

            context.AddSource("GitAssemblyInfo.g.cs",
                string.Format(
                    CultureInfo.InvariantCulture,
                    $"// <autogenerated/>{0}{1}{0}{0}[assembly: GitInformationAttribute(\"{2}\", \"{3}\", \"{4}\", typeof({5}{6}))]{0}",
                    Environment.NewLine,
                    splittedLen > 0 && !string.Equals(
                        gitinformationNamespace,
                        usingStr.ToString(),
                        StringComparison.Ordinal) ? $"using {usingStr};{Environment.NewLine}using {gitinformationNamespace};" : $"using {gitinformationNamespace};",
                    this.RunGit("describe --all --always --dirty", Directory.GetParent(gitBuildInfoJsonFile.Path).FullName),
                    this.RunGit("rev-parse --short HEAD", Directory.GetParent(gitBuildInfoJsonFile.Path).FullName),
                    this.RunGit("name-rev --name-only HEAD", Directory.GetParent(gitBuildInfoJsonFile.Path).FullName),
                    splittedLen > 0 ? splitted[splittedLen - 1] : options.AssemblyType,
                    options.IsGeneric ? "<>" : string.Empty));
        }

        private string RunGit(string arguments, string workingDirectory)
        {
            using var pro1 = new Process();
            pro1.StartInfo.FileName = "git";
            pro1.StartInfo.Arguments = arguments;
            pro1.StartInfo.RedirectStandardOutput = true;
            pro1.StartInfo.UseShellExecute = false;
            pro1.StartInfo.CreateNoWindow = true;
            pro1.StartInfo.WorkingDirectory = workingDirectory;
            try
            {
                _ = pro1.Start();
                var git_out = pro1.StandardOutput.ReadToEnd();
                pro1.WaitForExit();

                // handle all cases of possible endlines.
                git_out = git_out.Replace("\r\n", string.Empty);
                git_out = git_out.Replace("\n", string.Empty);
                return git_out.Replace("\r", string.Empty);
            }
            catch (Win32Exception)
            {
                return "Not a git clone or git is not in Path.";
            }
        }
    }
}
